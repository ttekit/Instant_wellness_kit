
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ProductOnPackage` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model ProductOnPackage
 * 
 */
export type ProductOnPackageModel = runtime.Types.Result.DefaultSelection<Prisma.$ProductOnPackagePayload>

export type AggregateProductOnPackage = {
  _count: ProductOnPackageCountAggregateOutputType | null
  _avg: ProductOnPackageAvgAggregateOutputType | null
  _sum: ProductOnPackageSumAggregateOutputType | null
  _min: ProductOnPackageMinAggregateOutputType | null
  _max: ProductOnPackageMaxAggregateOutputType | null
}

export type ProductOnPackageAvgAggregateOutputType = {
  productId: number | null
  packageId: number | null
}

export type ProductOnPackageSumAggregateOutputType = {
  productId: number | null
  packageId: number | null
}

export type ProductOnPackageMinAggregateOutputType = {
  productId: number | null
  packageId: number | null
}

export type ProductOnPackageMaxAggregateOutputType = {
  productId: number | null
  packageId: number | null
}

export type ProductOnPackageCountAggregateOutputType = {
  productId: number
  packageId: number
  _all: number
}


export type ProductOnPackageAvgAggregateInputType = {
  productId?: true
  packageId?: true
}

export type ProductOnPackageSumAggregateInputType = {
  productId?: true
  packageId?: true
}

export type ProductOnPackageMinAggregateInputType = {
  productId?: true
  packageId?: true
}

export type ProductOnPackageMaxAggregateInputType = {
  productId?: true
  packageId?: true
}

export type ProductOnPackageCountAggregateInputType = {
  productId?: true
  packageId?: true
  _all?: true
}

export type ProductOnPackageAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProductOnPackage to aggregate.
   */
  where?: Prisma.ProductOnPackageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductOnPackages to fetch.
   */
  orderBy?: Prisma.ProductOnPackageOrderByWithRelationInput | Prisma.ProductOnPackageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ProductOnPackageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductOnPackages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductOnPackages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ProductOnPackages
  **/
  _count?: true | ProductOnPackageCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: ProductOnPackageAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: ProductOnPackageSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ProductOnPackageMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ProductOnPackageMaxAggregateInputType
}

export type GetProductOnPackageAggregateType<T extends ProductOnPackageAggregateArgs> = {
      [P in keyof T & keyof AggregateProductOnPackage]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateProductOnPackage[P]>
    : Prisma.GetScalarType<T[P], AggregateProductOnPackage[P]>
}




export type ProductOnPackageGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ProductOnPackageWhereInput
  orderBy?: Prisma.ProductOnPackageOrderByWithAggregationInput | Prisma.ProductOnPackageOrderByWithAggregationInput[]
  by: Prisma.ProductOnPackageScalarFieldEnum[] | Prisma.ProductOnPackageScalarFieldEnum
  having?: Prisma.ProductOnPackageScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ProductOnPackageCountAggregateInputType | true
  _avg?: ProductOnPackageAvgAggregateInputType
  _sum?: ProductOnPackageSumAggregateInputType
  _min?: ProductOnPackageMinAggregateInputType
  _max?: ProductOnPackageMaxAggregateInputType
}

export type ProductOnPackageGroupByOutputType = {
  productId: number
  packageId: number
  _count: ProductOnPackageCountAggregateOutputType | null
  _avg: ProductOnPackageAvgAggregateOutputType | null
  _sum: ProductOnPackageSumAggregateOutputType | null
  _min: ProductOnPackageMinAggregateOutputType | null
  _max: ProductOnPackageMaxAggregateOutputType | null
}

type GetProductOnPackageGroupByPayload<T extends ProductOnPackageGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ProductOnPackageGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ProductOnPackageGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ProductOnPackageGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ProductOnPackageGroupByOutputType[P]>
      }
    >
  >



export type ProductOnPackageWhereInput = {
  AND?: Prisma.ProductOnPackageWhereInput | Prisma.ProductOnPackageWhereInput[]
  OR?: Prisma.ProductOnPackageWhereInput[]
  NOT?: Prisma.ProductOnPackageWhereInput | Prisma.ProductOnPackageWhereInput[]
  productId?: Prisma.IntFilter<"ProductOnPackage"> | number
  packageId?: Prisma.IntFilter<"ProductOnPackage"> | number
  product?: Prisma.XOR<Prisma.ProductScalarRelationFilter, Prisma.ProductWhereInput>
  package?: Prisma.XOR<Prisma.ProductPackageScalarRelationFilter, Prisma.ProductPackageWhereInput>
}

export type ProductOnPackageOrderByWithRelationInput = {
  productId?: Prisma.SortOrder
  packageId?: Prisma.SortOrder
  product?: Prisma.ProductOrderByWithRelationInput
  package?: Prisma.ProductPackageOrderByWithRelationInput
}

export type ProductOnPackageWhereUniqueInput = Prisma.AtLeast<{
  productId_packageId?: Prisma.ProductOnPackageProductIdPackageIdCompoundUniqueInput
  AND?: Prisma.ProductOnPackageWhereInput | Prisma.ProductOnPackageWhereInput[]
  OR?: Prisma.ProductOnPackageWhereInput[]
  NOT?: Prisma.ProductOnPackageWhereInput | Prisma.ProductOnPackageWhereInput[]
  productId?: Prisma.IntFilter<"ProductOnPackage"> | number
  packageId?: Prisma.IntFilter<"ProductOnPackage"> | number
  product?: Prisma.XOR<Prisma.ProductScalarRelationFilter, Prisma.ProductWhereInput>
  package?: Prisma.XOR<Prisma.ProductPackageScalarRelationFilter, Prisma.ProductPackageWhereInput>
}, "productId_packageId">

export type ProductOnPackageOrderByWithAggregationInput = {
  productId?: Prisma.SortOrder
  packageId?: Prisma.SortOrder
  _count?: Prisma.ProductOnPackageCountOrderByAggregateInput
  _avg?: Prisma.ProductOnPackageAvgOrderByAggregateInput
  _max?: Prisma.ProductOnPackageMaxOrderByAggregateInput
  _min?: Prisma.ProductOnPackageMinOrderByAggregateInput
  _sum?: Prisma.ProductOnPackageSumOrderByAggregateInput
}

export type ProductOnPackageScalarWhereWithAggregatesInput = {
  AND?: Prisma.ProductOnPackageScalarWhereWithAggregatesInput | Prisma.ProductOnPackageScalarWhereWithAggregatesInput[]
  OR?: Prisma.ProductOnPackageScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ProductOnPackageScalarWhereWithAggregatesInput | Prisma.ProductOnPackageScalarWhereWithAggregatesInput[]
  productId?: Prisma.IntWithAggregatesFilter<"ProductOnPackage"> | number
  packageId?: Prisma.IntWithAggregatesFilter<"ProductOnPackage"> | number
}

export type ProductOnPackageCreateInput = {
  product: Prisma.ProductCreateNestedOneWithoutPackagesInput
  package: Prisma.ProductPackageCreateNestedOneWithoutProductsInput
}

export type ProductOnPackageUncheckedCreateInput = {
  productId: number
  packageId: number
}

export type ProductOnPackageUpdateInput = {
  product?: Prisma.ProductUpdateOneRequiredWithoutPackagesNestedInput
  package?: Prisma.ProductPackageUpdateOneRequiredWithoutProductsNestedInput
}

export type ProductOnPackageUncheckedUpdateInput = {
  productId?: Prisma.IntFieldUpdateOperationsInput | number
  packageId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductOnPackageCreateManyInput = {
  productId: number
  packageId: number
}

export type ProductOnPackageUpdateManyMutationInput = {

}

export type ProductOnPackageUncheckedUpdateManyInput = {
  productId?: Prisma.IntFieldUpdateOperationsInput | number
  packageId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductOnPackageListRelationFilter = {
  every?: Prisma.ProductOnPackageWhereInput
  some?: Prisma.ProductOnPackageWhereInput
  none?: Prisma.ProductOnPackageWhereInput
}

export type ProductOnPackageOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ProductOnPackageProductIdPackageIdCompoundUniqueInput = {
  productId: number
  packageId: number
}

export type ProductOnPackageCountOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  packageId?: Prisma.SortOrder
}

export type ProductOnPackageAvgOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  packageId?: Prisma.SortOrder
}

export type ProductOnPackageMaxOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  packageId?: Prisma.SortOrder
}

export type ProductOnPackageMinOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  packageId?: Prisma.SortOrder
}

export type ProductOnPackageSumOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  packageId?: Prisma.SortOrder
}

export type ProductOnPackageCreateNestedManyWithoutPackageInput = {
  create?: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutPackageInput, Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput> | Prisma.ProductOnPackageCreateWithoutPackageInput[] | Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput[]
  connectOrCreate?: Prisma.ProductOnPackageCreateOrConnectWithoutPackageInput | Prisma.ProductOnPackageCreateOrConnectWithoutPackageInput[]
  createMany?: Prisma.ProductOnPackageCreateManyPackageInputEnvelope
  connect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
}

export type ProductOnPackageUncheckedCreateNestedManyWithoutPackageInput = {
  create?: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutPackageInput, Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput> | Prisma.ProductOnPackageCreateWithoutPackageInput[] | Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput[]
  connectOrCreate?: Prisma.ProductOnPackageCreateOrConnectWithoutPackageInput | Prisma.ProductOnPackageCreateOrConnectWithoutPackageInput[]
  createMany?: Prisma.ProductOnPackageCreateManyPackageInputEnvelope
  connect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
}

export type ProductOnPackageUpdateManyWithoutPackageNestedInput = {
  create?: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutPackageInput, Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput> | Prisma.ProductOnPackageCreateWithoutPackageInput[] | Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput[]
  connectOrCreate?: Prisma.ProductOnPackageCreateOrConnectWithoutPackageInput | Prisma.ProductOnPackageCreateOrConnectWithoutPackageInput[]
  upsert?: Prisma.ProductOnPackageUpsertWithWhereUniqueWithoutPackageInput | Prisma.ProductOnPackageUpsertWithWhereUniqueWithoutPackageInput[]
  createMany?: Prisma.ProductOnPackageCreateManyPackageInputEnvelope
  set?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  disconnect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  delete?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  connect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  update?: Prisma.ProductOnPackageUpdateWithWhereUniqueWithoutPackageInput | Prisma.ProductOnPackageUpdateWithWhereUniqueWithoutPackageInput[]
  updateMany?: Prisma.ProductOnPackageUpdateManyWithWhereWithoutPackageInput | Prisma.ProductOnPackageUpdateManyWithWhereWithoutPackageInput[]
  deleteMany?: Prisma.ProductOnPackageScalarWhereInput | Prisma.ProductOnPackageScalarWhereInput[]
}

export type ProductOnPackageUncheckedUpdateManyWithoutPackageNestedInput = {
  create?: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutPackageInput, Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput> | Prisma.ProductOnPackageCreateWithoutPackageInput[] | Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput[]
  connectOrCreate?: Prisma.ProductOnPackageCreateOrConnectWithoutPackageInput | Prisma.ProductOnPackageCreateOrConnectWithoutPackageInput[]
  upsert?: Prisma.ProductOnPackageUpsertWithWhereUniqueWithoutPackageInput | Prisma.ProductOnPackageUpsertWithWhereUniqueWithoutPackageInput[]
  createMany?: Prisma.ProductOnPackageCreateManyPackageInputEnvelope
  set?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  disconnect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  delete?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  connect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  update?: Prisma.ProductOnPackageUpdateWithWhereUniqueWithoutPackageInput | Prisma.ProductOnPackageUpdateWithWhereUniqueWithoutPackageInput[]
  updateMany?: Prisma.ProductOnPackageUpdateManyWithWhereWithoutPackageInput | Prisma.ProductOnPackageUpdateManyWithWhereWithoutPackageInput[]
  deleteMany?: Prisma.ProductOnPackageScalarWhereInput | Prisma.ProductOnPackageScalarWhereInput[]
}

export type ProductOnPackageCreateNestedManyWithoutProductInput = {
  create?: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutProductInput, Prisma.ProductOnPackageUncheckedCreateWithoutProductInput> | Prisma.ProductOnPackageCreateWithoutProductInput[] | Prisma.ProductOnPackageUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.ProductOnPackageCreateOrConnectWithoutProductInput | Prisma.ProductOnPackageCreateOrConnectWithoutProductInput[]
  createMany?: Prisma.ProductOnPackageCreateManyProductInputEnvelope
  connect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
}

export type ProductOnPackageUncheckedCreateNestedManyWithoutProductInput = {
  create?: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutProductInput, Prisma.ProductOnPackageUncheckedCreateWithoutProductInput> | Prisma.ProductOnPackageCreateWithoutProductInput[] | Prisma.ProductOnPackageUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.ProductOnPackageCreateOrConnectWithoutProductInput | Prisma.ProductOnPackageCreateOrConnectWithoutProductInput[]
  createMany?: Prisma.ProductOnPackageCreateManyProductInputEnvelope
  connect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
}

export type ProductOnPackageUpdateManyWithoutProductNestedInput = {
  create?: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutProductInput, Prisma.ProductOnPackageUncheckedCreateWithoutProductInput> | Prisma.ProductOnPackageCreateWithoutProductInput[] | Prisma.ProductOnPackageUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.ProductOnPackageCreateOrConnectWithoutProductInput | Prisma.ProductOnPackageCreateOrConnectWithoutProductInput[]
  upsert?: Prisma.ProductOnPackageUpsertWithWhereUniqueWithoutProductInput | Prisma.ProductOnPackageUpsertWithWhereUniqueWithoutProductInput[]
  createMany?: Prisma.ProductOnPackageCreateManyProductInputEnvelope
  set?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  disconnect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  delete?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  connect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  update?: Prisma.ProductOnPackageUpdateWithWhereUniqueWithoutProductInput | Prisma.ProductOnPackageUpdateWithWhereUniqueWithoutProductInput[]
  updateMany?: Prisma.ProductOnPackageUpdateManyWithWhereWithoutProductInput | Prisma.ProductOnPackageUpdateManyWithWhereWithoutProductInput[]
  deleteMany?: Prisma.ProductOnPackageScalarWhereInput | Prisma.ProductOnPackageScalarWhereInput[]
}

export type ProductOnPackageUncheckedUpdateManyWithoutProductNestedInput = {
  create?: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutProductInput, Prisma.ProductOnPackageUncheckedCreateWithoutProductInput> | Prisma.ProductOnPackageCreateWithoutProductInput[] | Prisma.ProductOnPackageUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.ProductOnPackageCreateOrConnectWithoutProductInput | Prisma.ProductOnPackageCreateOrConnectWithoutProductInput[]
  upsert?: Prisma.ProductOnPackageUpsertWithWhereUniqueWithoutProductInput | Prisma.ProductOnPackageUpsertWithWhereUniqueWithoutProductInput[]
  createMany?: Prisma.ProductOnPackageCreateManyProductInputEnvelope
  set?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  disconnect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  delete?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  connect?: Prisma.ProductOnPackageWhereUniqueInput | Prisma.ProductOnPackageWhereUniqueInput[]
  update?: Prisma.ProductOnPackageUpdateWithWhereUniqueWithoutProductInput | Prisma.ProductOnPackageUpdateWithWhereUniqueWithoutProductInput[]
  updateMany?: Prisma.ProductOnPackageUpdateManyWithWhereWithoutProductInput | Prisma.ProductOnPackageUpdateManyWithWhereWithoutProductInput[]
  deleteMany?: Prisma.ProductOnPackageScalarWhereInput | Prisma.ProductOnPackageScalarWhereInput[]
}

export type ProductOnPackageCreateWithoutPackageInput = {
  product: Prisma.ProductCreateNestedOneWithoutPackagesInput
}

export type ProductOnPackageUncheckedCreateWithoutPackageInput = {
  productId: number
}

export type ProductOnPackageCreateOrConnectWithoutPackageInput = {
  where: Prisma.ProductOnPackageWhereUniqueInput
  create: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutPackageInput, Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput>
}

export type ProductOnPackageCreateManyPackageInputEnvelope = {
  data: Prisma.ProductOnPackageCreateManyPackageInput | Prisma.ProductOnPackageCreateManyPackageInput[]
  skipDuplicates?: boolean
}

export type ProductOnPackageUpsertWithWhereUniqueWithoutPackageInput = {
  where: Prisma.ProductOnPackageWhereUniqueInput
  update: Prisma.XOR<Prisma.ProductOnPackageUpdateWithoutPackageInput, Prisma.ProductOnPackageUncheckedUpdateWithoutPackageInput>
  create: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutPackageInput, Prisma.ProductOnPackageUncheckedCreateWithoutPackageInput>
}

export type ProductOnPackageUpdateWithWhereUniqueWithoutPackageInput = {
  where: Prisma.ProductOnPackageWhereUniqueInput
  data: Prisma.XOR<Prisma.ProductOnPackageUpdateWithoutPackageInput, Prisma.ProductOnPackageUncheckedUpdateWithoutPackageInput>
}

export type ProductOnPackageUpdateManyWithWhereWithoutPackageInput = {
  where: Prisma.ProductOnPackageScalarWhereInput
  data: Prisma.XOR<Prisma.ProductOnPackageUpdateManyMutationInput, Prisma.ProductOnPackageUncheckedUpdateManyWithoutPackageInput>
}

export type ProductOnPackageScalarWhereInput = {
  AND?: Prisma.ProductOnPackageScalarWhereInput | Prisma.ProductOnPackageScalarWhereInput[]
  OR?: Prisma.ProductOnPackageScalarWhereInput[]
  NOT?: Prisma.ProductOnPackageScalarWhereInput | Prisma.ProductOnPackageScalarWhereInput[]
  productId?: Prisma.IntFilter<"ProductOnPackage"> | number
  packageId?: Prisma.IntFilter<"ProductOnPackage"> | number
}

export type ProductOnPackageCreateWithoutProductInput = {
  package: Prisma.ProductPackageCreateNestedOneWithoutProductsInput
}

export type ProductOnPackageUncheckedCreateWithoutProductInput = {
  packageId: number
}

export type ProductOnPackageCreateOrConnectWithoutProductInput = {
  where: Prisma.ProductOnPackageWhereUniqueInput
  create: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutProductInput, Prisma.ProductOnPackageUncheckedCreateWithoutProductInput>
}

export type ProductOnPackageCreateManyProductInputEnvelope = {
  data: Prisma.ProductOnPackageCreateManyProductInput | Prisma.ProductOnPackageCreateManyProductInput[]
  skipDuplicates?: boolean
}

export type ProductOnPackageUpsertWithWhereUniqueWithoutProductInput = {
  where: Prisma.ProductOnPackageWhereUniqueInput
  update: Prisma.XOR<Prisma.ProductOnPackageUpdateWithoutProductInput, Prisma.ProductOnPackageUncheckedUpdateWithoutProductInput>
  create: Prisma.XOR<Prisma.ProductOnPackageCreateWithoutProductInput, Prisma.ProductOnPackageUncheckedCreateWithoutProductInput>
}

export type ProductOnPackageUpdateWithWhereUniqueWithoutProductInput = {
  where: Prisma.ProductOnPackageWhereUniqueInput
  data: Prisma.XOR<Prisma.ProductOnPackageUpdateWithoutProductInput, Prisma.ProductOnPackageUncheckedUpdateWithoutProductInput>
}

export type ProductOnPackageUpdateManyWithWhereWithoutProductInput = {
  where: Prisma.ProductOnPackageScalarWhereInput
  data: Prisma.XOR<Prisma.ProductOnPackageUpdateManyMutationInput, Prisma.ProductOnPackageUncheckedUpdateManyWithoutProductInput>
}

export type ProductOnPackageCreateManyPackageInput = {
  productId: number
}

export type ProductOnPackageUpdateWithoutPackageInput = {
  product?: Prisma.ProductUpdateOneRequiredWithoutPackagesNestedInput
}

export type ProductOnPackageUncheckedUpdateWithoutPackageInput = {
  productId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductOnPackageUncheckedUpdateManyWithoutPackageInput = {
  productId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductOnPackageCreateManyProductInput = {
  packageId: number
}

export type ProductOnPackageUpdateWithoutProductInput = {
  package?: Prisma.ProductPackageUpdateOneRequiredWithoutProductsNestedInput
}

export type ProductOnPackageUncheckedUpdateWithoutProductInput = {
  packageId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductOnPackageUncheckedUpdateManyWithoutProductInput = {
  packageId?: Prisma.IntFieldUpdateOperationsInput | number
}



export type ProductOnPackageSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  productId?: boolean
  packageId?: boolean
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
  package?: boolean | Prisma.ProductPackageDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productOnPackage"]>

export type ProductOnPackageSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  productId?: boolean
  packageId?: boolean
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
  package?: boolean | Prisma.ProductPackageDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productOnPackage"]>

export type ProductOnPackageSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  productId?: boolean
  packageId?: boolean
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
  package?: boolean | Prisma.ProductPackageDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productOnPackage"]>

export type ProductOnPackageSelectScalar = {
  productId?: boolean
  packageId?: boolean
}

export type ProductOnPackageOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"productId" | "packageId", ExtArgs["result"]["productOnPackage"]>
export type ProductOnPackageInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
  package?: boolean | Prisma.ProductPackageDefaultArgs<ExtArgs>
}
export type ProductOnPackageIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
  package?: boolean | Prisma.ProductPackageDefaultArgs<ExtArgs>
}
export type ProductOnPackageIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
  package?: boolean | Prisma.ProductPackageDefaultArgs<ExtArgs>
}

export type $ProductOnPackagePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ProductOnPackage"
  objects: {
    product: Prisma.$ProductPayload<ExtArgs>
    package: Prisma.$ProductPackagePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    productId: number
    packageId: number
  }, ExtArgs["result"]["productOnPackage"]>
  composites: {}
}

export type ProductOnPackageGetPayload<S extends boolean | null | undefined | ProductOnPackageDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload, S>

export type ProductOnPackageCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ProductOnPackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProductOnPackageCountAggregateInputType | true
  }

export interface ProductOnPackageDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductOnPackage'], meta: { name: 'ProductOnPackage' } }
  /**
   * Find zero or one ProductOnPackage that matches the filter.
   * @param {ProductOnPackageFindUniqueArgs} args - Arguments to find a ProductOnPackage
   * @example
   * // Get one ProductOnPackage
   * const productOnPackage = await prisma.productOnPackage.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ProductOnPackageFindUniqueArgs>(args: Prisma.SelectSubset<T, ProductOnPackageFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ProductOnPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ProductOnPackage that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ProductOnPackageFindUniqueOrThrowArgs} args - Arguments to find a ProductOnPackage
   * @example
   * // Get one ProductOnPackage
   * const productOnPackage = await prisma.productOnPackage.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ProductOnPackageFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ProductOnPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProductOnPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProductOnPackage that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductOnPackageFindFirstArgs} args - Arguments to find a ProductOnPackage
   * @example
   * // Get one ProductOnPackage
   * const productOnPackage = await prisma.productOnPackage.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ProductOnPackageFindFirstArgs>(args?: Prisma.SelectSubset<T, ProductOnPackageFindFirstArgs<ExtArgs>>): Prisma.Prisma__ProductOnPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProductOnPackage that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductOnPackageFindFirstOrThrowArgs} args - Arguments to find a ProductOnPackage
   * @example
   * // Get one ProductOnPackage
   * const productOnPackage = await prisma.productOnPackage.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ProductOnPackageFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ProductOnPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProductOnPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ProductOnPackages that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductOnPackageFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ProductOnPackages
   * const productOnPackages = await prisma.productOnPackage.findMany()
   * 
   * // Get first 10 ProductOnPackages
   * const productOnPackages = await prisma.productOnPackage.findMany({ take: 10 })
   * 
   * // Only select the `productId`
   * const productOnPackageWithProductIdOnly = await prisma.productOnPackage.findMany({ select: { productId: true } })
   * 
   */
  findMany<T extends ProductOnPackageFindManyArgs>(args?: Prisma.SelectSubset<T, ProductOnPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ProductOnPackage.
   * @param {ProductOnPackageCreateArgs} args - Arguments to create a ProductOnPackage.
   * @example
   * // Create one ProductOnPackage
   * const ProductOnPackage = await prisma.productOnPackage.create({
   *   data: {
   *     // ... data to create a ProductOnPackage
   *   }
   * })
   * 
   */
  create<T extends ProductOnPackageCreateArgs>(args: Prisma.SelectSubset<T, ProductOnPackageCreateArgs<ExtArgs>>): Prisma.Prisma__ProductOnPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ProductOnPackages.
   * @param {ProductOnPackageCreateManyArgs} args - Arguments to create many ProductOnPackages.
   * @example
   * // Create many ProductOnPackages
   * const productOnPackage = await prisma.productOnPackage.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ProductOnPackageCreateManyArgs>(args?: Prisma.SelectSubset<T, ProductOnPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ProductOnPackages and returns the data saved in the database.
   * @param {ProductOnPackageCreateManyAndReturnArgs} args - Arguments to create many ProductOnPackages.
   * @example
   * // Create many ProductOnPackages
   * const productOnPackage = await prisma.productOnPackage.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ProductOnPackages and only return the `productId`
   * const productOnPackageWithProductIdOnly = await prisma.productOnPackage.createManyAndReturn({
   *   select: { productId: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ProductOnPackageCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ProductOnPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ProductOnPackage.
   * @param {ProductOnPackageDeleteArgs} args - Arguments to delete one ProductOnPackage.
   * @example
   * // Delete one ProductOnPackage
   * const ProductOnPackage = await prisma.productOnPackage.delete({
   *   where: {
   *     // ... filter to delete one ProductOnPackage
   *   }
   * })
   * 
   */
  delete<T extends ProductOnPackageDeleteArgs>(args: Prisma.SelectSubset<T, ProductOnPackageDeleteArgs<ExtArgs>>): Prisma.Prisma__ProductOnPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ProductOnPackage.
   * @param {ProductOnPackageUpdateArgs} args - Arguments to update one ProductOnPackage.
   * @example
   * // Update one ProductOnPackage
   * const productOnPackage = await prisma.productOnPackage.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ProductOnPackageUpdateArgs>(args: Prisma.SelectSubset<T, ProductOnPackageUpdateArgs<ExtArgs>>): Prisma.Prisma__ProductOnPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ProductOnPackages.
   * @param {ProductOnPackageDeleteManyArgs} args - Arguments to filter ProductOnPackages to delete.
   * @example
   * // Delete a few ProductOnPackages
   * const { count } = await prisma.productOnPackage.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ProductOnPackageDeleteManyArgs>(args?: Prisma.SelectSubset<T, ProductOnPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProductOnPackages.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductOnPackageUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ProductOnPackages
   * const productOnPackage = await prisma.productOnPackage.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ProductOnPackageUpdateManyArgs>(args: Prisma.SelectSubset<T, ProductOnPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProductOnPackages and returns the data updated in the database.
   * @param {ProductOnPackageUpdateManyAndReturnArgs} args - Arguments to update many ProductOnPackages.
   * @example
   * // Update many ProductOnPackages
   * const productOnPackage = await prisma.productOnPackage.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ProductOnPackages and only return the `productId`
   * const productOnPackageWithProductIdOnly = await prisma.productOnPackage.updateManyAndReturn({
   *   select: { productId: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ProductOnPackageUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ProductOnPackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ProductOnPackage.
   * @param {ProductOnPackageUpsertArgs} args - Arguments to update or create a ProductOnPackage.
   * @example
   * // Update or create a ProductOnPackage
   * const productOnPackage = await prisma.productOnPackage.upsert({
   *   create: {
   *     // ... data to create a ProductOnPackage
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ProductOnPackage we want to update
   *   }
   * })
   */
  upsert<T extends ProductOnPackageUpsertArgs>(args: Prisma.SelectSubset<T, ProductOnPackageUpsertArgs<ExtArgs>>): Prisma.Prisma__ProductOnPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductOnPackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ProductOnPackages.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductOnPackageCountArgs} args - Arguments to filter ProductOnPackages to count.
   * @example
   * // Count the number of ProductOnPackages
   * const count = await prisma.productOnPackage.count({
   *   where: {
   *     // ... the filter for the ProductOnPackages we want to count
   *   }
   * })
  **/
  count<T extends ProductOnPackageCountArgs>(
    args?: Prisma.Subset<T, ProductOnPackageCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ProductOnPackageCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ProductOnPackage.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductOnPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ProductOnPackageAggregateArgs>(args: Prisma.Subset<T, ProductOnPackageAggregateArgs>): Prisma.PrismaPromise<GetProductOnPackageAggregateType<T>>

  /**
   * Group by ProductOnPackage.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductOnPackageGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ProductOnPackageGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ProductOnPackageGroupByArgs['orderBy'] }
      : { orderBy?: ProductOnPackageGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ProductOnPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductOnPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ProductOnPackage model
 */
readonly fields: ProductOnPackageFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ProductOnPackage.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ProductOnPackageClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  product<T extends Prisma.ProductDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProductDefaultArgs<ExtArgs>>): Prisma.Prisma__ProductClient<runtime.Types.Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  package<T extends Prisma.ProductPackageDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProductPackageDefaultArgs<ExtArgs>>): Prisma.Prisma__ProductPackageClient<runtime.Types.Result.GetResult<Prisma.$ProductPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ProductOnPackage model
 */
export interface ProductOnPackageFieldRefs {
  readonly productId: Prisma.FieldRef<"ProductOnPackage", 'Int'>
  readonly packageId: Prisma.FieldRef<"ProductOnPackage", 'Int'>
}
    

// Custom InputTypes
/**
 * ProductOnPackage findUnique
 */
export type ProductOnPackageFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * Filter, which ProductOnPackage to fetch.
   */
  where: Prisma.ProductOnPackageWhereUniqueInput
}

/**
 * ProductOnPackage findUniqueOrThrow
 */
export type ProductOnPackageFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * Filter, which ProductOnPackage to fetch.
   */
  where: Prisma.ProductOnPackageWhereUniqueInput
}

/**
 * ProductOnPackage findFirst
 */
export type ProductOnPackageFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * Filter, which ProductOnPackage to fetch.
   */
  where?: Prisma.ProductOnPackageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductOnPackages to fetch.
   */
  orderBy?: Prisma.ProductOnPackageOrderByWithRelationInput | Prisma.ProductOnPackageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProductOnPackages.
   */
  cursor?: Prisma.ProductOnPackageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductOnPackages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductOnPackages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProductOnPackages.
   */
  distinct?: Prisma.ProductOnPackageScalarFieldEnum | Prisma.ProductOnPackageScalarFieldEnum[]
}

/**
 * ProductOnPackage findFirstOrThrow
 */
export type ProductOnPackageFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * Filter, which ProductOnPackage to fetch.
   */
  where?: Prisma.ProductOnPackageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductOnPackages to fetch.
   */
  orderBy?: Prisma.ProductOnPackageOrderByWithRelationInput | Prisma.ProductOnPackageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProductOnPackages.
   */
  cursor?: Prisma.ProductOnPackageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductOnPackages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductOnPackages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProductOnPackages.
   */
  distinct?: Prisma.ProductOnPackageScalarFieldEnum | Prisma.ProductOnPackageScalarFieldEnum[]
}

/**
 * ProductOnPackage findMany
 */
export type ProductOnPackageFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * Filter, which ProductOnPackages to fetch.
   */
  where?: Prisma.ProductOnPackageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductOnPackages to fetch.
   */
  orderBy?: Prisma.ProductOnPackageOrderByWithRelationInput | Prisma.ProductOnPackageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ProductOnPackages.
   */
  cursor?: Prisma.ProductOnPackageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductOnPackages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductOnPackages.
   */
  skip?: number
  distinct?: Prisma.ProductOnPackageScalarFieldEnum | Prisma.ProductOnPackageScalarFieldEnum[]
}

/**
 * ProductOnPackage create
 */
export type ProductOnPackageCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * The data needed to create a ProductOnPackage.
   */
  data: Prisma.XOR<Prisma.ProductOnPackageCreateInput, Prisma.ProductOnPackageUncheckedCreateInput>
}

/**
 * ProductOnPackage createMany
 */
export type ProductOnPackageCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ProductOnPackages.
   */
  data: Prisma.ProductOnPackageCreateManyInput | Prisma.ProductOnPackageCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ProductOnPackage createManyAndReturn
 */
export type ProductOnPackageCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * The data used to create many ProductOnPackages.
   */
  data: Prisma.ProductOnPackageCreateManyInput | Prisma.ProductOnPackageCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ProductOnPackage update
 */
export type ProductOnPackageUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * The data needed to update a ProductOnPackage.
   */
  data: Prisma.XOR<Prisma.ProductOnPackageUpdateInput, Prisma.ProductOnPackageUncheckedUpdateInput>
  /**
   * Choose, which ProductOnPackage to update.
   */
  where: Prisma.ProductOnPackageWhereUniqueInput
}

/**
 * ProductOnPackage updateMany
 */
export type ProductOnPackageUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ProductOnPackages.
   */
  data: Prisma.XOR<Prisma.ProductOnPackageUpdateManyMutationInput, Prisma.ProductOnPackageUncheckedUpdateManyInput>
  /**
   * Filter which ProductOnPackages to update
   */
  where?: Prisma.ProductOnPackageWhereInput
  /**
   * Limit how many ProductOnPackages to update.
   */
  limit?: number
}

/**
 * ProductOnPackage updateManyAndReturn
 */
export type ProductOnPackageUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * The data used to update ProductOnPackages.
   */
  data: Prisma.XOR<Prisma.ProductOnPackageUpdateManyMutationInput, Prisma.ProductOnPackageUncheckedUpdateManyInput>
  /**
   * Filter which ProductOnPackages to update
   */
  where?: Prisma.ProductOnPackageWhereInput
  /**
   * Limit how many ProductOnPackages to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ProductOnPackage upsert
 */
export type ProductOnPackageUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * The filter to search for the ProductOnPackage to update in case it exists.
   */
  where: Prisma.ProductOnPackageWhereUniqueInput
  /**
   * In case the ProductOnPackage found by the `where` argument doesn't exist, create a new ProductOnPackage with this data.
   */
  create: Prisma.XOR<Prisma.ProductOnPackageCreateInput, Prisma.ProductOnPackageUncheckedCreateInput>
  /**
   * In case the ProductOnPackage was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ProductOnPackageUpdateInput, Prisma.ProductOnPackageUncheckedUpdateInput>
}

/**
 * ProductOnPackage delete
 */
export type ProductOnPackageDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
  /**
   * Filter which ProductOnPackage to delete.
   */
  where: Prisma.ProductOnPackageWhereUniqueInput
}

/**
 * ProductOnPackage deleteMany
 */
export type ProductOnPackageDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProductOnPackages to delete
   */
  where?: Prisma.ProductOnPackageWhereInput
  /**
   * Limit how many ProductOnPackages to delete.
   */
  limit?: number
}

/**
 * ProductOnPackage without action
 */
export type ProductOnPackageDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductOnPackage
   */
  select?: Prisma.ProductOnPackageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductOnPackage
   */
  omit?: Prisma.ProductOnPackageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductOnPackageInclude<ExtArgs> | null
}
